[Performance fundamentals] https://developer.mozilla.org/en-US/Apps/Fundamentals/Performance/Performance_fundamentals
    - To display graphics, developers can use HTML or CSS (i.e. high-level declarative languages), or use low-level imperative interfaces offered by the <canvas> element (which includes WebGL). Somewhere "in between" HTML/CSS and Canvas is SVG, which offers some benefits of both.
    
    -  The key to fast startup is to keep two things in mind: UPP (user-perceived performance) is all that matters, and there's a "critical path" to each user-perceived event above. The critical path is exactly and only the code that must run to produce the event.

    - to reach a user-perceived startup event more quickly, the main "trick" is run only the code on the critical path. Shorten the critical path by simplifying the scene.

    - JavaScript is a dynamically-typed language, and the Web platform allows loading code, HTML, CSS, images, and other resources dynamically. These features can be used to defer work that's off the critical path by loading unnecessary content "lazily" some time after startup.

    - Another problem that can delay startup is idle time, caused by waiting for responses to requests (like database loads). To avoid this problem, applications should issue requests as early as possible in startup (this is called "front-loading"). Then when the data is needed later, hopefully it's already available and the application doesn't have to wait.

    - locally-cached, static resources can be loaded much faster than dynamic data fetched over high-latency, low-bandwidth mobile networks. Network requests should never be on the critical path to early application startup.

    - Use HTML and CSS to implement content that's mostly static, scrolled, and infrequently animated. Use Canvas to implement highly dynamic content, like games that need tight control over rendering and don't need theming.

    - Applications that constantly fire timers or keep unnecessary animations running prevent CPUs from entering low-power mode. Power-efficient applications shouldn't do that.

    - When applications are sent to the background, a visibilitychange event is fired on their documents. This event is a developer's friend; applications should listen for it. Applications that drop as many loaded resources as possible when sent to the background use less memory and are less likely discarded

    - you have a long list of elements (let’s say tweets), don’t move them all. Instead, keep in your DOM tree only the ones that are visible and a few on either side of the currently visible set of tweets. Hide or remove the rest. Keeping the data in a JavaScript object instead of accessing the DOM can vastly improve your app's performance.

    - Firefox, Chrome, and other browsers include built-in tools that can help you diagnose slow page rendering. In particular, "Firefox's Network Monitor" will display a precise timeline of when each network request on your page happens, how large it is, and how long it takes.

    - If your page contains JavaScript code that is taking a long time to run, the "JavaScript profiler" will pinpoint the slowest lines of code

    - The Built-in Gecko Profiler is a very useful tool that provides even more detailed information about which parts of the browser code are running slowly while the profiler runs.

    - Using YSlow (which requires Firebug) provides extremely helpful recommendations for improving performance. Many of the identified problems and suggested solutions are especially useful for mobile browsers. You should definitely run YSlow and follow its recommendations.

    
[Optimizing startup performance] https://developer.mozilla.org/en-US/Apps/Fundamentals/Performance/Optimizing_startup_performance

    - starting up as asynchronously as possible
      you should write your code so that your app creates a Web worker that does as much as possible in a background thread (for example, fetching and processing data.) Then, anything that must be done on the main thread (such as user events and rendering UI) should be broken up into small pieces so that the app's event loop continues to cycle while it starts up. This will prevent the app, browser, and/or device from appearing to have locked up.

    - [Web Workers]  
       https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers
      [Concurrency model and Event Loop]
       https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop
    
    - unless you can easily pull out the "pure calculation" chunks of your startup process into workers, you'll wind up having to run most or all of your startup code on the main thread.

    - Use the defer or async attribute on script tags needed at startup. This allows HTML parsers to process documents more efficiently.

    - If you need to decode asset files (for example, decoding JPEG files and turning them into raw texture data for later use by WebGL), that's great to do in workers.

    - Don't include scripts or stylesheets that don't participate in the critical path in your startup HTML file. Load them only when needed.

    - The more stuff you can do asynchronously, the better advantage your app can take of multicore processors.

    - The most important thing to do to try to help with the main code's startup process is to refactor the code into small pieces that can be done in chunks interspersed across multiple calls to your app's main loop, so that the main thread gets to handle input and the like.

    - consider having background music playing or a nice splash screen displayed. In between calculations, update your progress indicator, make changes to the display, or anything else you might be able to do to help the user feel like your app is doing something instead of sitting there quietly.


[UI Synchronicity] https://developer.mozilla.org/en-US/Apps/Fundamentals/Performance/UI_Synchronicity
    
    - A Sync UI is a user interface that is tightly coupled to the state of background data or processing. Some examples of Sync UIs are loading spinners or modal dialogs. The intent of a Sync UI is to block the user from continued interaction until the relevant processing or state changes have been completed. Sync UIs should be used in situations where the next interaction is dependent on the completion of the current interaction.

    - An Async UI is a user interface that is decoupled from any processing or background data state. Async UI has perceived benefits over a Sync UI:

        - The user interface responds to feedback immediately and feels responsive
        - Processing occurs in the background
        - UI Continuation doesn't block the interface


[CSS and JavaScript animation performance] https://developer.mozilla.org/en-US/Apps/Fundamentals/Performance/CSS_JavaScript_animation_performance













[FireFox Developer Tools] https://developer.mozilla.org/en-US/docs/Tools
    
    Performace : https://developer.mozilla.org/en-US/docs/Tools/Performance
                 https://developer.mozilla.org/en-US/docs/Tools/Performance/UI_Tour

                 [Frame rate] https://developer.mozilla.org/en-US/docs/Tools/Performance/Frame_rate
                     - Frame rate is a measure of a website's responsiveness. A low or inconsistent frame rate can make a site appear unresponsive or janky, making for a bad user experience.

                       A frame rate of 60fps is the target for smooth performance, giving you a time budget of 16.7ms for all the updates needed in response to some event.

                       The frame rate graph in the Performance tool shows you the frame rate over the course of a recording. It gives you a quick indication of where your site might be having problems

                     - consider splitting it into pieces and running the pieces inside requestAnimationFrame, or even running the entire function in a worker. 

                 [Intensive_JavaScript] https://developer.mozilla.org/en-US/docs/Tools/Performance/Scenarios/Intensive_JavaScript

                     - By default the browser uses a single thread to run all the JavaScript in your page as well as to perform layout, reflows, and garbage collection. This means that long-running JavaScript functions can block the thread, leading to an unresponsive page and a bad user experience.

                     - two different approaches to fixing them. The first is to split long-running functions into pieces and use requestAnimationFrame to schedule each piece, and the second is to run the whole function in a separate thread using a web worker.
                     
                 [WaterFall] https://developer.mozilla.org/en-US/docs/Tools/Performance/Waterfall
                     - The Waterfall gives you insight into the sorts of things the browser is doing as it runs your site or app. It's based on the idea that the things a browser does when running a site can be divided into various types - running JavaScript, updating layout, and so on - and that at any given point in time, the browser is doing one of those things.

                       So if you see a sign of a performance problem - a drop in the frame rate, for example - you can go to the Waterfall to see what the browser was doing at that point in the recording.

                     - algorithm the browser uses to update the page in response to some event : 

                        (1) JavaScript Function Call: some event - for example, a DOM event - causes some JavaScript in the page to run. The JavaScript changes some of the page's DOM or CSSOM.
                        (2) Recalculate Style: if the browser thinks the computed styles for page elements have changed, it must then recalculate them.
                        (3) Layout: next, the browser uses the computed styles to figure out the position and geometry for the elements. This operation is labeled "layout" but is also sometimes called "reflow".
                        (4) Paint: finally, the browser needs to repaint the elements to the screen. One last step is not shown in this sequence: the page may be split into layers, which are painted independently and then combined in a process called "Composition".

                     - CSS animations update the page without having to run any JavaScript.

                     - Not all CSS property changes cause a reflow. Changing properties that can alter an object's geometry and position, such as width, display, font-size, or top, will cause a reflow. However, changing properties that don't alter geometry or position, such as color or opacity, will not.

                     - For a rate of 60 frames per second, that gives the browser 16.7 milliseconds to execute the complete flow.

                     - By default, a site's JavaScript is executed in the same thread that the browser uses for layout updates, repaints, DOM events, and so on. This means that long-running JavaScript functions can cause unresponsiveness (jank): animations may not be smooth, or the site might even freeze.

                     - [Garbage collection] GC is relevant to performance because while it's running the JavaScript engine must be paused, so your program is suspended and will be completely unresponsive.


                 [Call Tree] https://developer.mozilla.org/en-US/docs/Tools/Performance/Call_Tree
                     - The Call Tree tells you which JavaScript functions the browser spent the most time in. By analyzing its results, you can find bottlenecks in your code

                     - Samples is the number of samples that were taken when we were executing this particular function.

                       Self Cost is that number as a percentage of the total number of samples in the selected portion of the recording.

                     - Functions with a relatively high Self Cost are good candidates for optimization, either because they take a long time to run, or because they are called very often.

                 [Flame Chart] https://developer.mozilla.org/en-US/docs/Tools/Performance/Flame_Chart
                     - The Flame Chart shows you the state of the JavaScript stack for your code at every millisecond during the performance profile.

                       This gives you a way to know exactly which function was executing at any point during the recording, how long it ran for, and where it was called from.

                     - The Call Tree and the Flame Chart are both used to analyze your site's JavaScript, and they both use the same data: a sample of the JavaScript engine's stack, taken periodically during the recording.

                 [Allocations] https://developer.mozilla.org/en-US/docs/Tools/Performance/Allocations
                     - The Allocations view in the Performance tool shows you which functions in your page are allocating the most memory over the course of the profile.

                       For performance this is important mostly because allocating a lot of memory, or making a lot of allocations, can trigger garbage collection. This in turn can hurt the responsiveness of a page.

                     - "Self" records samples taken only in this function. "Total" records samples taken in this function or in functions called by this function. A

                     - the main connection between the allocation profile of a site and its responsiveness is the cost of garbage collection (GC).

                       With a garbage-collected language, like JavaScript, the runtime periodically needs to walk the heap looking for objects that are no longer reachable, and then freeing the memory they occupy. While GC events like this are executing, the JavaScript engine must be paused, so your program is suspended and will be completely unresponsive.

                     - To reduce the impact on responsiveness, SpiderMonkey (the JavaScript engine in Firefox) can perform GC in small increments, letting the program run in between. Sometimes, though, it needs to perform a full non-incremental collection, and the program has to wait for it to finish.

                     - GC events are shown as red markers in the Waterfall view, and are a big red flag for responsiveness

                     - allocation pressure - allocating a lot of memory, or allocating memory at a high rate - makes SpiderMonkey more likely to run garbage collection, and more likely to run full, non-incremental garbage collection.


    Network Monitor : https://developer.mozilla.org/en-US/docs/Tools/Network_Monitor



[When to load JS in page flow]
    http://stackoverflow.com/questions/436411/where-should-i-put-script-tags-in-html-markup
    - The current state-of-the-art is to put scripts in the <head> tag and use the async or defer attributes. This allows your scripts to be downloaded asap without blocking your browser.

    https://developers.google.com/speed/docs/insights/BlockingJS


