[Performance fundamentals] https://developer.mozilla.org/en-US/Apps/Fundamentals/Performance/Performance_fundamentals
    - To display graphics, developers can use HTML or CSS (i.e. high-level declarative languages), or use low-level imperative interfaces offered by the <canvas> element (which includes WebGL). Somewhere "in between" HTML/CSS and Canvas is SVG, which offers some benefits of both.
    
    -  The key to fast startup is to keep two things in mind: UPP (user-perceived performance) is all that matters, and there's a "critical path" to each user-perceived event above. The critical path is exactly and only the code that must run to produce the event.

    - to reach a user-perceived startup event more quickly, the main "trick" is run only the code on the critical path. Shorten the critical path by simplifying the scene.

    - JavaScript is a dynamically-typed language, and the Web platform allows loading code, HTML, CSS, images, and other resources dynamically. These features can be used to defer work that's off the critical path by loading unnecessary content "lazily" some time after startup.

    - Another problem that can delay startup is idle time, caused by waiting for responses to requests (like database loads). To avoid this problem, applications should issue requests as early as possible in startup (this is called "front-loading"). Then when the data is needed later, hopefully it's already available and the application doesn't have to wait.

    - locally-cached, static resources can be loaded much faster than dynamic data fetched over high-latency, low-bandwidth mobile networks. Network requests should never be on the critical path to early application startup.

    - Use HTML and CSS to implement content that's mostly static, scrolled, and infrequently animated. Use Canvas to implement highly dynamic content, like games that need tight control over rendering and don't need theming.

    - Applications that constantly fire timers or keep unnecessary animations running prevent CPUs from entering low-power mode. Power-efficient applications shouldn't do that.

    - When applications are sent to the background, a visibilitychange event is fired on their documents. This event is a developer's friend; applications should listen for it. Applications that drop as many loaded resources as possible when sent to the background use less memory and are less likely discarded

    - you have a long list of elements (let’s say tweets), don’t move them all. Instead, keep in your DOM tree only the ones that are visible and a few on either side of the currently visible set of tweets. Hide or remove the rest. Keeping the data in a JavaScript object instead of accessing the DOM can vastly improve your app's performance.

    - Firefox, Chrome, and other browsers include built-in tools that can help you diagnose slow page rendering. In particular, "Firefox's Network Monitor" will display a precise timeline of when each network request on your page happens, how large it is, and how long it takes.

    - If your page contains JavaScript code that is taking a long time to run, the "JavaScript profiler" will pinpoint the slowest lines of code

    - The Built-in Gecko Profiler is a very useful tool that provides even more detailed information about which parts of the browser code are running slowly while the profiler runs.

    - Using YSlow (which requires Firebug) provides extremely helpful recommendations for improving performance. Many of the identified problems and suggested solutions are especially useful for mobile browsers. You should definitely run YSlow and follow its recommendations.

    
[Optimizing startup performance] https://developer.mozilla.org/en-US/Apps/Fundamentals/Performance/Optimizing_startup_performance

    - starting up as asynchronously as possible
      you should write your code so that your app creates a Web worker that does as much as possible in a background thread (for example, fetching and processing data.) Then, anything that must be done on the main thread (such as user events and rendering UI) should be broken up into small pieces so that the app's event loop continues to cycle while it starts up. This will prevent the app, browser, and/or device from appearing to have locked up.

    - [Web Workers]  
       https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers
      [Concurrency model and Event Loop]
       https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop
    
    - unless you can easily pull out the "pure calculation" chunks of your startup process into workers, you'll wind up having to run most or all of your startup code on the main thread.

    - Use the defer or async attribute on script tags needed at startup. This allows HTML parsers to process documents more efficiently.

    - If you need to decode asset files (for example, decoding JPEG files and turning them into raw texture data for later use by WebGL), that's great to do in workers.

    - Don't include scripts or stylesheets that don't participate in the critical path in your startup HTML file. Load them only when needed.

    - The more stuff you can do asynchronously, the better advantage your app can take of multicore processors.

    - The most important thing to do to try to help with the main code's startup process is to refactor the code into small pieces that can be done in chunks interspersed across multiple calls to your app's main loop, so that the main thread gets to handle input and the like.

    - consider having background music playing or a nice splash screen displayed. In between calculations, update your progress indicator, make changes to the display, or anything else you might be able to do to help the user feel like your app is doing something instead of sitting there quietly.


[UI Synchronicity] https://developer.mozilla.org/en-US/Apps/Fundamentals/Performance/UI_Synchronicity
    
    - A Sync UI is a user interface that is tightly coupled to the state of background data or processing. Some examples of Sync UIs are loading spinners or modal dialogs. The intent of a Sync UI is to block the user from continued interaction until the relevant processing or state changes have been completed. Sync UIs should be used in situations where the next interaction is dependent on the completion of the current interaction.

    - An Async UI is a user interface that is decoupled from any processing or background data state. Async UI has perceived benefits over a Sync UI:

        - The user interface responds to feedback immediately and feels responsive
        - Processing occurs in the background
        - UI Continuation doesn't block the interface


[CSS and JavaScript animation performance] https://developer.mozilla.org/en-US/Apps/Fundamentals/Performance/CSS_JavaScript_animation_performance













[FireFox Developer Tools] https://developer.mozilla.org/en-US/docs/Tools
    
    Performace : https://developer.mozilla.org/en-US/docs/Tools/Performance
                 https://developer.mozilla.org/en-US/docs/Tools/Performance/UI_Tour

                 [Frame rate] https://developer.mozilla.org/en-US/docs/Tools/Performance/Frame_rate
                     - Frame rate is a measure of a website's responsiveness. A low or inconsistent frame rate can make a site appear unresponsive or janky, making for a bad user experience.

                       A frame rate of 60fps is the target for smooth performance, giving you a time budget of 16.7ms for all the updates needed in response to some event.

                       The frame rate graph in the Performance tool shows you the frame rate over the course of a recording. It gives you a quick indication of where your site might be having problems

                     - consider splitting it into pieces and running the pieces inside requestAnimationFrame, or even running the entire function in a worker. 

                 [Intensive_JavaScript] https://developer.mozilla.org/en-US/docs/Tools/Performance/Scenarios/Intensive_JavaScript

                     - By default the browser uses a single thread to run all the JavaScript in your page as well as to perform layout, reflows, and garbage collection. This means that long-running JavaScript functions can block the thread, leading to an unresponsive page and a bad user experience.

                     - two different approaches to fixing them. The first is to split long-running functions into pieces and use requestAnimationFrame to schedule each piece, and the second is to run the whole function in a separate thread using a web worker.
                     
                           (1) we'll split up the function into a number of much smaller self-contained functions, and schedule each one using requestAnimationFrame().

                             requestAnimationFrame() tells the browser to run the given function in each frame, just before it performs a repaint. As long as each function is reasonably small, the browser should be able to keep inside its frame budget.

                           (2) Web workers enable you to run JavaScript in a separate thread. The main thread and the worker thread can't call each other directly, but communicate using an asynchronous messaging API.
                           
                             the worker runs all the primality tests, and it doesn't seem to have any effect at all on the responsiveness of the main thread. This might seem unlikely, but because workers run in a separate thread, they can take advantage of multi-core processors, which a single-threaded web site can't.
                             
                             The main limitation of web workers is that DOM APIs are not available to code running in a worker.
                             
                     - window.requestAnimationFrame(callback); : https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame

                         The window.requestAnimationFrame() method tells the browser that you wish to perform an animation and requests that the browser call a specified function to update an animation before the next repaint. The method takes as an argument a callback to be invoked before the repaint.

                         Your callback routine must itself call requestAnimationFrame() if you want to animate another frame at the next repaint.

                         You should call this method whenever you're ready to update your animation onscreen. This will request that your animation function be called before the browser performs the next repaint. The number of callbacks is usually 60 times per second, but will generally match the display refresh rate in most web browsers

                         [Animation] https://developer.mozilla.org/en-US/Apps/Fundamentals/Performance/CSS_JavaScript_animation_performance#Off_main_thread_animation

                                     The requestAnimationFrame() API provides an efficient way to make animations in JavaScript. The callback function of the method is called by the browser before the next repaint on each frame. Compared to setTimeout()/setInterval(), which need a specific delay parameter, requestAnimationFrame() is much more efficient. Developers can create an animation by simply changing an element's style each time the loop is called (or updating the Canvas draw, or whatever.)

                 [animation_performance] https://developer.mozilla.org/en-US/Apps/Fundamentals/Performance/CSS_JavaScript_animation_performance
                     - There are many ways to implement web animations, such as CSS transitions/animations or JavaScript-based animations (using requestAnimationFrame().

                     -  in most cases, the performance of CSS-based animations is almost the same as JavaScripted animations 

                     - CSS transitions/animations are simply resampling element styles in the main UI thread before each repaint event happens, which is almost the same as resampling element styles via a requestAnimationFrame() callback, also triggered before the next repaint. If both animations are made in the main UI thread, there is no difference performance-wise.

                     - Off main thread animation
                       we'd argue that CSS animations are the better choice. But how? The key is that as long as the properties we want to animate do not trigger reflow/repaint (read CSS triggers for more information), we can move those sampling operations out of the main thread. The most common property is the CSS transform. If an element is promoted as a layer, animating transform properties can be done in the GPU, meaning better performance/efficiency, especially on mobile. 
                       

                 [WaterFall] https://developer.mozilla.org/en-US/docs/Tools/Performance/Waterfall
                     - The Waterfall gives you insight into the sorts of things the browser is doing as it runs your site or app. It's based on the idea that the things a browser does when running a site can be divided into various types - running JavaScript, updating layout, and so on - and that at any given point in time, the browser is doing one of those things.

                       So if you see a sign of a performance problem - a drop in the frame rate, for example - you can go to the Waterfall to see what the browser was doing at that point in the recording.

                     - algorithm the browser uses to update the page in response to some event : 

                        (1) JavaScript Function Call: some event - for example, a DOM event - causes some JavaScript in the page to run. The JavaScript changes some of the page's DOM or CSSOM.
                        (2) Recalculate Style: if the browser thinks the computed styles for page elements have changed, it must then recalculate them.
                        (3) Layout: next, the browser uses the computed styles to figure out the position and geometry for the elements. This operation is labeled "layout" but is also sometimes called "reflow".
                        (4) Paint: finally, the browser needs to repaint the elements to the screen. One last step is not shown in this sequence: the page may be split into layers, which are painted independently and then combined in a process called "Composition".

                     - CSS animations update the page without having to run any JavaScript.

                     - Not all CSS property changes cause a reflow. Changing properties that can alter an object's geometry and position, such as width, display, font-size, or top, will cause a reflow. However, changing properties that don't alter geometry or position, such as color or opacity, will not.

                     - For a rate of 60 frames per second, that gives the browser 16.7 milliseconds to execute the complete flow.

                     - By default, a site's JavaScript is executed in the same thread that the browser uses for layout updates, repaints, DOM events, and so on. This means that long-running JavaScript functions can cause unresponsiveness (jank): animations may not be smooth, or the site might even freeze.

                     - [Garbage collection] GC is relevant to performance because while it's running the JavaScript engine must be paused, so your program is suspended and will be completely unresponsive.


                 [Call Tree] https://developer.mozilla.org/en-US/docs/Tools/Performance/Call_Tree
                     - The Call Tree tells you which JavaScript functions the browser spent the most time in. By analyzing its results, you can find bottlenecks in your code

                     - Samples is the number of samples that were taken when we were executing this particular function.

                       Self Cost is that number as a percentage of the total number of samples in the selected portion of the recording.

                     - Functions with a relatively high Self Cost are good candidates for optimization, either because they take a long time to run, or because they are called very often.

                 [Flame Chart] https://developer.mozilla.org/en-US/docs/Tools/Performance/Flame_Chart
                     - The Flame Chart shows you the state of the JavaScript stack for your code at every millisecond during the performance profile.

                       This gives you a way to know exactly which function was executing at any point during the recording, how long it ran for, and where it was called from.

                     - The Call Tree and the Flame Chart are both used to analyze your site's JavaScript, and they both use the same data: a sample of the JavaScript engine's stack, taken periodically during the recording.

                 [Allocations] https://developer.mozilla.org/en-US/docs/Tools/Performance/Allocations
                     - The Allocations view in the Performance tool shows you which functions in your page are allocating the most memory over the course of the profile.

                       For performance this is important mostly because allocating a lot of memory, or making a lot of allocations, can trigger garbage collection. This in turn can hurt the responsiveness of a page.

                     - "Self" records samples taken only in this function. "Total" records samples taken in this function or in functions called by this function. A

                     - the main connection between the allocation profile of a site and its responsiveness is the cost of garbage collection (GC).

                       With a garbage-collected language, like JavaScript, the runtime periodically needs to walk the heap looking for objects that are no longer reachable, and then freeing the memory they occupy. While GC events like this are executing, the JavaScript engine must be paused, so your program is suspended and will be completely unresponsive.

                     - To reduce the impact on responsiveness, SpiderMonkey (the JavaScript engine in Firefox) can perform GC in small increments, letting the program run in between. Sometimes, though, it needs to perform a full non-incremental collection, and the program has to wait for it to finish.

                     - GC events are shown as red markers in the Waterfall view, and are a big red flag for responsiveness

                     - allocation pressure - allocating a lot of memory, or allocating memory at a high rate - makes SpiderMonkey more likely to run garbage collection, and more likely to run full, non-incremental garbage collection.


    Network Monitor : https://developer.mozilla.org/en-US/docs/Tools/Network_Monitor







[Professional Website Performance Optimizing The Front End And The Back End by Peter Smith – 2013]
- https://github.com/imkrimerman/javascript-ebooks/blob/master/%5BProfessional%20Website%20Performance%20Optimizing%20The%20Front%20End%20And%20The%20Back%20End%20by%20Peter%20Smith%20%E2%80%93%202013%5D.pdf
- (backend only) https://books.google.com.au/books?id=8YyhNm3QHSIC&pg=PA139&dq=ajax+preemptive+loading&hl=zh-TW&source=gbs_toc_r&cad=4#v=onepage&q&f=false


    - [Tool] https://www.webpagetest.org

    - Avoid empty src="" (will issue a request)

    - spefifying the width/height of image (browser can render smoothly after image downloaded.)(p.89)

    - Nginx as a Reverse Proxy to Apache
    - Nginx can act as Reverse Proxy and Load Balancer ans Static File Server. (p.177)

    - HW Load Balancer v.s. SW Load Balancer
      HW : on OSI layer 3 and 4 (TCP/IP)
      SW : on OSI layer 7

    - Load Balancer set a cookie when a client first visit. (The cookie contains the ID of the back-end server handling the request.)

    - In MySQL sharding (scaling write) setup, you must add a extra step of logic to your app code.
      Fisrt, you must keep track of which shards reside on which servers.(store this lookup table in app config or memcache). Every time your app performs a query, it must consult this table to determine which server to send the query.
      In Mongo, all this is taken care of automatically through the use of two additional services : mogos and configuration servers. App is unaware that sharding is even happening. (p.344)

    - Choosing the sharding key is the most difficult part of setting up sharding. (key = email address , username or...any fields) (p.344)

    - Replication offers you security against node failing(and some degree of read scaling).
      While sharding provides write scaling.
      Combine them togerther is the most popular ways for setting up Mongo cluster.
      (Each shard is a replica set.)  (p.349 and 350)
      
    - Count the number of Elements in DOM : document.getElementsByTagName('*').length

    - Cache a reference to a element if you want to access it many times.(don't have to traverse the tree and find it.)

    - Fetch the JS via XHR and passing the reponse to eval() or insert in to DOM via inside a <script> tag.
      OR 
      $("#hidden_modal").load( "cropper_modal_outter.html", function(){ // load complete });
      OR 
      var element1 = document.createElement("script");
      element1.src = "js/cropper/common.js";
      document.body.appendChild(element1);

    - MySQL Tuning : 
          Table Cache : store table in memory.
          Thread Cache : reuse Thread from a pool for new connection.


[Google DevTools]
  https://developers.google.com/web/tools/chrome-devtools/
  http://discover-devtools.codeschool.com/


[Google] https://developers.google.com/web/fundamentals/performance/
    - keep pre-load data to a minimum so that your app loads fast, and use idle time to load remaining data.
         
    - Vector graphics is the use of polygons to represent images in computer graphics.
      Vector graphics use lines, points, and polygons to represent an image.
      Vector images are zoom and resolution-independent
      prefer vector images whenever possible as they are resolution independent and always deliver sharp results
      
    - SVG [Scalable Vector Graphics]
      SVG is an XML-based image format
      SVG files should be minified to reduce their size
      SVG files should be compressed with GZIP
      All modern browsers support Scalable Vector Graphics (SVG), which is an XML-based image format for two-dimensional graphics: we can embed the SVG markup directly on the page, or as an external resource. In turn, an SVG file can be created by most vector-based drawing software, or by hand and directly in your favorite text editor.

    - [Font] the browser must construct the render tree, which is dependent on the DOM and CSSOM trees, before it knows which font resources it needs in order to render the text. As a result, font requests are delayed well after other critical resources, and the browser may be blocked from rendering text until the resource is fetched.

    - Cache-Control "no-cache" and "no-store"
        "no-cache" indicates that the returned response can't be used to satisfy a subsequent request to the same URL without first checking with the server if the response has changed. As a result, if a proper validation token (ETag) is present, no-cache incurs a roundtrip to validate the cached response, but can eliminate the download if the resource has not changed.

        By contrast, "no-store" is much simpler. It simply disallows the browser and all intermediate caches from storing any version of the returned response—for example, one containing private personal or banking data. Every time the user requests this asset, a request is sent to the server and a full response is downloaded.
  
    - You change the URL of the resource and force the user to download the new response whenever its content changes. Typically, you do this by embedding a fingerprint of the file, or a version number, in its filename—for example, style.x234dff.css.

    - The combination of ETag, Cache-Control, and unique URLs allows you to deliver the best of all worlds: long-lived expiration times, control over where the response can be cached, and on-demand updates.

    - Before the browser can render the page, it needs to construct the DOM and CSSOM trees. As a result, we need to ensure that we deliver both the HTML and CSS to the browser as quickly as possible.
      HTML markup is transformed into a Document Object Model (DOM); CSS markup is transformed into a CSS Object Model (CSSOM).
      DOM and CSSOM are independent data structures.

    - Why does the CSSOM have a tree structure? When computing the final set of styles for any object on the page, the browser starts with the most general rule applicable to that node (for example, if it is a child of a body element, then all body styles apply) and then recursively refines the computed styles by applying more specific rules; that is, the rules "cascade down."

    - The CSSOM and DOM trees are combined into a "render tree", which is then used to compute the layout of each visible element and serves as an input to the paint process that renders the pixels to screen.
      
       (1) The DOM and CSSOM trees are combined to form the render tree.
       (2) "Render tree" contains only the nodes required to render the page.
       (3) "Layout" computes the exact position and size of each object.
       (4) The last step is "paint", which takes in the final render tree and renders the pixels to the screen.

    - Some nodes are hidden via CSS and are also omitted from the render tree

    - Note: As a brief aside, note that visibility: hidden is different from display: none. The former makes the element invisible, but the element still occupies space in the layout (that is, it's rendered as an empty box), whereas the latter (display: none) removes the element entirely from the render tree such that the element is invisible and is not part of the layout.

    - The final output is a render that contains both the content and style information of all the visible content on the screen. With the render tree in place, we can proceed to the "layout" stage. 
      Up to this point we've calculated which nodes should be visible and their computed styles, but we have not calculated their exact position and size within the viewport of the device---that's the "layout" stage, also known as "reflow."
      The output of the layout process is a "box model," which precisely captures the exact position and size of each element within the viewport: all of the relative measurements are converted to absolute pixels on the screen.

    - Finally, now that we know which nodes are visible, and their computed styles and geometry, we can pass this information to the final stage, which converts each node in the render tree to actual pixels on the screen. This step is often referred to as "painting" or "rasterizing."

    - Here's a quick recap of the browser's steps:
        Process HTML markup and build the DOM tree.
        Process CSS markup and build the CSSOM tree.
        Combine the DOM and CSSOM into a render tree.
        Run layout on the render tree to compute geometry of each node.
        Paint the individual nodes to the screen.
      Optimizing the critical rendering path is the process of minimizing the total amount of time spent performing steps 1 through 5 in the above sequence.
      Both HTML and CSS are render blocking resources. 

    - By default, CSS is treated as a render blocking resource, which means that the browser won't render any processed content until the CSSOM is constructed. Make sure to keep your CSS lean, deliver it as quickly as possible, and "use media types and queries to unblock rendering".

      (1) By default, CSS is treated as a render blocking resource.
      (2) Media types and media queries allow us to mark some CSS resources as non-render blocking.
      (3) The browser downloads all CSS resources, regardless of blocking or non-blocking behavior.

    - If we have some CSS styles that are only used under certain conditions, for example, when the page is being printed or being projected onto a large monitor? It would be nice if we didn’t have to block rendering on these resources.
        CSS "media types" and "media queries" allow us to address these use cases:
          <link href="style.css" rel="stylesheet">
          <link href="print.css" rel="stylesheet" media="print">
          <link href="other.css" rel="stylesheet" media="(min-width: 40em)">
        the last stylesheet declaration provides a "media query," which is executed by the browser: if the conditions match, the browser blocks rendering until the style sheet is downloaded and processed.

        By using media queries, we can tailor our presentation to specific use cases, such as display versus print, and also to dynamic conditions such as changes in screen orientation, resize events, and more. When declaring your style sheet assets, pay close attention to the media type and queries; they greatly impact critical rendering path performance.

    - note that "render blocking" only refers to whether the browser has to hold the initial rendering of the page on that resource. In either case, the browser still downloads the CSS asset, albeit with a lower priority for non-blocking resources.

    - To deliver optimal performance, make your JavaScript async and eliminate any unnecessary JavaScript from the critical rendering path.

    - JavaScript
      (1)JavaScript can query and modify the DOM and the CSSOM.
      (2)JavaScript execution blocks on the CSSOM.
      (3)JavaScript blocks DOM construction unless explicitly declared as async.

    - while JavaScript affords us lots of power, it creates lots of additional limitations on how and when the page is rendered.

    - JS script is executed at the exact point where it is inserted in the document. When the HTML parser encounters a script tag, it pauses its process of constructing the DOM and yields control to the JavaScript engine; after the JavaScript engine finishes running, the browser then picks up where it left off and resumes DOM construction.

      In other words, our script block can't find any elements later in the page because they haven't been processed yet! Or, put slightly differently: executing our inline script blocks DOM construction, which also delays the initial render.

    - 
      (1)The location of the script in the document is significant.
      (2)When the browser encounters a script tag, DOM construction pauses until the script finishes executing.
      (3)JavaScript can query and modify the DOM and the CSSOM.
      (4)JavaScript execution pauses until the CSSOM is ready.
      To a large degree, "optimizing the critical rendering path" refers to understanding and optimizing the dependency graph between HTML, CSS, and JavaScript.

    - By default, JavaScript execution is "parser blocking": when the browser encounters a script in the document it must pause DOM construction, hand over control to the JavaScript runtime, and let the script execute before proceeding with DOM construction. We saw this in action with an inline script in our earlier example. In fact, inline scripts are always parser blocking unless you write additional code to defer their execution.

    - Whether we use a <script> tag or an inline JavaScript snippet, you'd expect both to behave the same way. In both cases, the browser pauses and executes the script before it can process the remainder of the document. However, in the case of an external JavaScript file the browser must pause to wait for the script to be fetched from disk, cache, or a remote server, which can add tens to thousands of milliseconds of delay to the critical rendering path.

    - Adding the async keyword to the script tag tells the browser not to block DOM construction while it waits for the script to become available, which can significantly improve performance.
      (or "defer" keyword)

    - https://developers.google.com/web/tools/lighthouse/
      The Lighthouse approach runs a series of automated tests against a page, and then generates a report on the page's CRP performance. 

    - The Navigation Timing API approach captures Real User Monitoring (RUM) metrics. As the name implies, these metrics are captured from real user interactions with your site and provide an accurate view into real-world CRP performance, as experienced by your users across a variety of devices and network conditions.

    - In general, a good approach is to use Lighthouse to identify obvious CRP optimization opportunities, and then to instrument your code with the Navigation Timing API to monitor how your app performs out in the wild.

    - The Navigation Timing API captures all the relevant timestamps and our code simply waits for the onload event to fire 
      var t = window.performance.timing,
      interactive = t.domInteractive - t.domLoading,

    - https://developers.google.com/web/fundamentals/performance/critical-rendering-path/analyzing-crp

    - !! Normally Browser wait for CSSOM before executing JavaScript. 
        - because the JavaScript might query the CSSOM, we must block the CSS file until it downloads before we can execute JavaScript.
        - as soon as the browser hits the script tag it blocks and waits until the CSSOM is constructed.
        - in order to execute the JavaScript file we have to block and wait for CSSOM; recall that JavaScript can query the CSSOM and hence the browser pauses until style.css is downloaded and CSSOM is constructed.
        - Parser blocking JavaScript forces the browser to wait for the CSSOM and pauses construction of the DOM, which in turn can significantly delay the time to first render.

    - An asynchronous script has several advantages: (keyword "async")
      The script is no longer parser blocking and is not part of the critical rendering path.
      Because there are no other critical scripts, the CSS doesn't need to block the domContentLoaded event.

    - Put CSS in the document head
      Specify all CSS resources as early as possible within the HTML document so that the browser can discover the <link> tags and dispatch the request for the CSS as soon as possible.
    
    - Inline render-blocking CSS
      For best performance, you may want to consider inlining the critical CSS directly into the HTML document. This eliminates additional roundtrips in the critical path and if done correctly can deliver a "one roundtrip" critical path length where only the HTML is a blocking resource.

    - Avoid setTimeout or setInterval for visual updates; always use requestAnimationFrame instead.
      Move long-running JavaScript off the main thread to Web Workers.

    - JavaScript runs on the browser’s main thread, right alongside style calculations, layout, and, in many cases, paint. If your JavaScript runs for a long time, it will block these other tasks, potentially causing frames to be missed.
      In many cases you can move pure computational work to Web Workers, if, for example, the it doesn’t require DOM access.
      Web Workers do not have DOM access. 

    - Reduce the complexity of your selectors (css)

    