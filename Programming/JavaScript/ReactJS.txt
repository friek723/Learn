
Tutorial : 
           
   https://onsen.io/blog/react-state-management-redux-store/
   https://www.codementor.io/reactjs/tutorial/intro-to-react-redux-pros

   [React-Router]
      http://stackoverflow.com/questions/31079081/programmatically-navigate-using-react-router


   10 Tips for Better Redux Architecture : https://medium.com/javascript-scene/10-tips-for-better-redux-architecture-69250425af44#.uy4idbsyx

   - Read HTML from file : 
      https://facebook.github.io/react/docs/dom-elements.html
      http://stackoverflow.com/questions/40108843/react-how-to-load-and-render-external-html-file
      https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Synchronous_and_Asynchronous_Requests
   
   - Chinese : http://huli.logdown.com/posts/276040-react-resource-consolidation


[React-Router] 
    react-router-tutorial : https://github.com/reactjs/react-router-tutorial/tree/master/lessons

    URL params : https://github.com/reactjs/react-router-tutorial/tree/master/lessons/06-params
    

[Flux] 
    http://blog.andrewray.me/flux-for-stupid-people/
    http://huli.logdown.com/posts/276040-react-resource-consolidation
    

[starter kit] - order by popularity
    !!!!! [Official React Starter Kit] https://github.com/facebookincubator/create-react-app
                                       Doc : https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md
                                       
            Supported by Official React : https://facebook.github.io/react/docs/installation.html
                                            https://facebook.github.io/react/blog/2016/07/22/create-apps-with-no-configuration.html

            Used by Redux : http://redux.js.org/docs/introduction/Examples.html

            Other : (1)https://medium.com/@diamondgfx/learning-react-with-create-react-app-part-1-a12e1833fdc
                    (2)https://medium.com/@diamondgfx/learning-react-with-create-react-app-part-2-3ad99f38b48d
                    (3)https://medium.com/@diamondgfx/learning-react-with-create-react-app-part-3-322447d14192
                    (4)https://medium.com/@diamondgfx/learning-react-with-create-react-app-part-4-9f843c8c1ccc
                    - https://www.fullstackreact.com/articles/using-create-react-app-with-a-server/
                    
            For native : https://github.com/react-community/create-react-native-app/

    !!!  https://github.com/kriasoft/react-starter-kit
    !!   https://github.com/davezuko/react-redux-starter-kit
    !    https://github.com/coryhouse/react-slingshot
    ! http://andrewhfarmer.com/starter-project/
       (Find your starter)



[Note on Officail Tutorial] https://facebook.github.io/react/docs/hello-world.html
    [JSX] : You can embed any JavaScript expression in JSX by wrapping it in curly braces.
            const element = (
              <h1>
                Hello, {formatName(user)}!
              </h1>
            );
            
            We split JSX over multiple lines for readability. While it isn't required, when doing this, we also recommend wrapping it in parentheses to avoid the pitfalls of automatic semicolon insertion.

            After compilation, JSX expressions become regular JavaScript objects.
            This means that you can use JSX inside of if statements and for loops, assign it to variables, accept it as arguments, and return it from functions

            Specifying Attributes with JSX : You should either use quotes (for string values) or curly braces (for expressions), but not both in the same attribute.
            Ex : const element = <div tabIndex="0"></div>;
                 const element = <img src={user.avatarUrl}></img>;

            Since JSX is closer to JavaScript than HTML, React DOM uses camelCase property naming convention instead of HTML attribute names.
            !! For example, class becomes className in JSX, and tabindex becomes tabIndex.

            It is safe to embed user input in JSX:
            const title = response.potentiallyMaliciousInput;
            // This is safe:
            const element = <h1>{title}</h1>;
            By default, React DOM escapes any values embedded in JSX before rendering them. Thus it ensures that you can never inject anything that's not explicitly written in your application. Everything is converted to a string before being rendered. This helps prevent XSS (cross-site-scripting) attacks.

            [JSX Represents Objects]
              Babel compiles JSX down to React.createElement() calls.
              These two examples are identical:
                const element = (
                  <h1 className="greeting">
                    Hello, world!
                  </h1>
                );

                const element = React.createElement(
                  'h1',
                  {className: 'greeting'},
                  'Hello, world!'
                );

              React.createElement() performs a few checks to help you write bug-free code but essentially it creates an object.
              These objects are called "React elements". You can think of them as descriptions of what you want to see on the screen. React reads these objects and uses them to construct the DOM and keep it up to date.
    
    [Rendering Elements]
        Elements are the smallest building blocks of React apps.
        An element describes what you want to see on the screen:
        const element = <h1>Hello, world</h1>;
        Unlike browser DOM elements, React elements are plain objects, and are cheap to create. React DOM takes care of updating the DOM to match the React elements.

        !! Elements are what components are "made of".

        <div id="root"></div> 
        We call this a "root" DOM node because everything inside it will be managed by React DOM.
        Applications built with just React usually have a single root DOM node. If you are integrating React into an existing app, you may have as many isolated root DOM nodes as you like.

        To render a React element into a root DOM node, pass both to ReactDOM.render():
          const element = <h1>Hello, world</h1>;
          ReactDOM.render(
            element,
            document.getElementById('root')
          );

        [Updating Element]
            React elements are immutable. Once you create an element, you can't change its children or attributes. An element is like a single frame in a movie: it represents the UI at a certain point in time.

            In practice, most React apps only call ReactDOM.render() once. 

            React DOM compares the element and its children to the previous one, and only applies the DOM updates necessary to bring the DOM to the desired state.

            thinking about how the UI should look at any given moment rather than how to change it over time eliminates a whole class of bugs.

    [Components and Props]            
        Components let you split the UI into independent, reusable pieces, and think about each piece in isolation.
        !! Conceptually, components are like JavaScript functions. They accept arbitrary inputs (called "props") and return React elements describing what should appear on the screen.

        [Functional and Class Components]
          The simplest way to define a component is to write a JavaScript function:
            function Welcome(props) {
              return <h1>Hello, {props.name}</h1>;
            }
          This function is a valid React component because it accepts a single "props" object argument with data and returns a React element. We call such components "functional" because they are literally JavaScript functions.
          You can also use an ES6 class to define a component:
            class Welcome extends React.Component {
              render() {
                return <h1>Hello, {this.props.name}</h1>;
              }
            }
          The above two components are equivalent from React's point of view.

        [Rendering a Component]
            elements can also represent user-defined components:
                const element = <Welcome name="Sara" />;
            When React sees an element representing a user-defined component, it passes JSX attributes to this component as a single object. We call this object "props".
            For example, this code renders "Hello, Sara" on the page:
              function Welcome(props) {
                return <h1>Hello, {props.name}</h1>;
              }
              const element = <Welcome name="Sara" />;
              ReactDOM.render(
                element,
                document.getElementById('root')
              );

            !!! Always start component names with a capital letter.
                For example, <div /> represents a DOM tag, but <Welcome /> represents a component and requires Welcome to be in scope.

            !! Components must return a single root element. This is why we added a <div> to contain all the <Welcome /> elements.
 
            Typically, new React apps have a single App component at the very top. However, if you integrate React into an existing app, you might start bottom-up with a small component like Button and gradually work your way to the top of the view hierarchy.

        [Props are Read-Only]
            Whether you declare a component as a function or a class, it must never modify its own props.
            Such functions are called "pure" because they do not attempt to change their inputs, and always return the same result for the same inputs.
            !!! All React components must act like pure functions with respect to their props.
                "State" allows React components to change their output over time in response to user actions, network responses, and anything else, without violating this rule.

        [State and Lifecycle]
            State is similar to props, but it is "private" and fully controlled by the component.
            We mentioned before that components defined as classes have some additional features. Local state is exactly that: a feature available only to classes.
            !!! If you don't use something in render(), it shouldn't be in the state.

        Add a class constructor that assigns the initial this.state :  
              class Clock extends React.Component {
                constructor(props) {
                  super(props);
                  this.state = {date: new Date()};
                }

                componentDidMount() {
                  this.timerID = setInterval(
                    () => this.tick(),
                    1000
                  );
                }

                componentWillUnmount() {
                  clearInterval(this.timerID);
                }

                tick() {
                  this.setState({
                    date: new Date()
                  });
                }

                render() {
                  return (
                    <div>
                      <h1>Hello, world!</h1>
                      <h2>It is {this.state.date.toLocaleTimeString()}.</h2>
                    </div>
                  );
                }
              }

              ReactDOM.render(
                <Clock />,
                document.getElementById('root')
              );


        Class components should always call the base constructor with props.

        We want to set up a timer whenever the Clock is rendered to the DOM for the first time. This is called "mounting" in React.
        We also want to clear that timer whenever the DOM produced by the Clock is removed. This is called "unmounting" in React.
        These methods are called "lifecycle hooks".

        While this.props is set up by React itself and this.state has a special meaning, you are free to add additional fields to the class manually if you need to store something that is not used for the visual output.

        !!! If you don't use something in render(), it shouldn't be in the state.

        !!! this.setState() : 
           Thanks to the this.setState() call, React knows the state has changed, and calls render() method again to learn what should be on the screen. 

        There are three things you should know about setState() :
            1. Do Not Modify State Directly, this will not re-render a component:
                  // Wrong
                  this.state.comment = 'Hello';
               Instead, use setState().
               The only place where you can assign this.state is the constructor.

            2. State Updates May Be Asynchronous
               React may batch multiple setState() calls into a single update for performance.
               Because this.props and this.state may be updated asynchronously, you should not rely on their values for calculating the next state.

               For example, this code may fail to update the counter:
                  // Wrong
                  this.setState({
                    counter: this.state.counter + this.props.increment,
                  });
               To fix it, use a second form of setState() that accepts a function rather than an object. That function will receive the previous state as the first argument, and the props at the time the update is applied as the second argument:
                  // Correct
                  this.setState(function(prevState, props) {
                    return {
                      counter: prevState.counter + props.increment
                    };
                  });

            3. State Updates are Merged
               When you call setState(), React merges the object you provide into the current state.
               For example, your state may contain several independent variables:
                  constructor(props) {
                    super(props);
                    this.state = {
                      posts: [],
                      comments: []
                    };
                  }
               Then you can update them independently with separate setState() calls:
                  componentDidMount() {
                    fetchPosts().then(response => {
                      this.setState({
                        posts: response.posts
                      });
                    });

                    fetchComments().then(response => {
                      this.setState({
                        comments: response.comments
                      });
                    });
                  }

        [The Data Flows Down]
            Neither parent nor child components can know if a certain component is stateful or stateless.
            This is why state is often called local or encapsulated. It is not accessible to any component other than the one that owns and sets it.
            A component may choose to pass its state down as props to its child components.
            This is commonly called a "top-down" or "unidirectional" data flow. Any state is always owned by some specific component, and any data or UI derived from that state can only affect components "below" them in the tree.
            If you imagine a component tree as a waterfall of props, each component's state is like an additional water source that joins it at an arbitrary point but also flows down.

    [Handling Events] 
        Handling events with React elements is very similar to handling events on DOM elements. There are some syntactic differences:
        #React events are named using camelCase, rather than lowercase.
        #With JSX you pass a function as the event handler, rather than a string.
         For example, the HTML:
           <button onclick="activateLasers()">
             Activate Lasers
           </button>
         is slightly different in React:
           <button onClick={activateLasers}>
             Activate Lasers
           </button>

        # Another difference is that you cannot return false to prevent default behavior in React. You must call preventDefault explicitly. 
        
        When using React you should generally not need to call addEventListener to add listeners to a DOM element after it is created. Instead, just provide a listener when the element is initially rendered.

        When you define a component using an ES6 class, a common pattern is for an event handler to be a method on the class. 
            class Toggle extends React.Component {
              constructor(props) {
                super(props);
                this.state = {isToggleOn: true};

                // This binding is necessary to make `this` work in the callback
                this.handleClick = this.handleClick.bind(this);
              }

              handleClick() {
                this.setState(prevState => ({
                  isToggleOn: !prevState.isToggleOn
                }));
              }

              render() {
                return (
                  <button onClick={this.handleClick}>
                    {this.state.isToggleOn ? 'ON' : 'OFF'}
                  </button>
                );
              }
            }

            ReactDOM.render(
              <Toggle />,
              document.getElementById('root')
            );

        You have to be careful about the meaning of this in JSX callbacks. In JavaScript, class methods are not bound by default. If you forget to bind this.handleClick and pass it to onClick, this will be undefined when the function is actually called.
        This is not React-specific behavior; it is a part of how functions work in JavaScript. Generally, if you refer to a method without () after it, such as onClick={this.handleClick}, you should bind that method.

    [Conditional Rendering]   
        Element Variables : 
            You can use variables to store elements. This can help you conditionally render a part of the component while the rest of the output doesn't change.
                render() {
                  const isLoggedIn = this.state.isLoggedIn;

                  let button = null;
                  if (isLoggedIn) {
                    button = <LogoutButton onClick={this.handleLogoutClick} />;
                  } else {
                    button = <LoginButton onClick={this.handleLoginClick} />;
                  }

                  return (
                    <div>
                      <Greeting isLoggedIn={isLoggedIn} />
                      {button}
                    </div>
                  );
                }


        !! In rare cases you might want a component to hide itself even though it was rendered by another component. To do this return null instead of its render output.

    [Lists and Keys]
        Rendering Multiple Components : 
          const numbers = [1, 2, 3, 4, 5];
          const listItems = numbers.map((number) =>
            <li>{number}</li>
          );
          ReactDOM.render(
            <ul>{listItems}</ul>,
            document.getElementById('root')
          );

        [Key] Keys help React identify which items have changed, are added, or are removed. Keys should be given to the elements inside the array to give the elements a stable identity.
              The best way to pick a key is to use a string that uniquely identifies a list item among its siblings. 
              A good rule of thumb is that elements inside the map() call need keys.
              Keys used within arrays should be unique among their siblings. However they don't need to be globally unique. 
              
            function NumberList(props) {
              const numbers = props.numbers;
              const listItems = numbers.map((number) =>
                <li key={number.toString()}>
                  {number}
                </li>
              );
              return (
                <ul>{listItems}</ul>
              );
            }

            const numbers = [1, 2, 3, 4, 5];
            ReactDOM.render(
              <NumberList numbers={numbers} />,
              document.getElementById('root')
            );
