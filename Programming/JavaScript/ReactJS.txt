
Tutorial : 
           
   https://onsen.io/blog/react-state-management-redux-store/
   https://www.codementor.io/reactjs/tutorial/intro-to-react-redux-pros

   [React-Router]
      http://stackoverflow.com/questions/31079081/programmatically-navigate-using-react-router


   10 Tips for Better Redux Architecture : https://medium.com/javascript-scene/10-tips-for-better-redux-architecture-69250425af44#.uy4idbsyx

   - Read HTML from file : 
      https://facebook.github.io/react/docs/dom-elements.html
      http://stackoverflow.com/questions/40108843/react-how-to-load-and-render-external-html-file
      https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Synchronous_and_Asynchronous_Requests
   
   - Chinese : http://huli.logdown.com/posts/276040-react-resource-consolidation


[Scroll to bottom]
    2nd answer : https://stackoverflow.com/questions/26556436/react-after-render-code

[React-Router] 
    react-router-tutorial : https://github.com/reactjs/react-router-tutorial/tree/master/lessons

    URL params : https://github.com/reactjs/react-router-tutorial/tree/master/lessons/06-params
    

[Flux] 
    http://blog.andrewray.me/flux-for-stupid-people/
    http://huli.logdown.com/posts/276040-react-resource-consolidation
    
[Ajax - interact with server]
    !! http://andrewhfarmer.com/react-ajax-best-practices/
       https://hashnode.com/post/5-best-libraries-for-making-ajax-calls-in-react-cis8x5f7k0jl7th53z68s41k1
       

[starter kit] - order by popularity
    !!!!! [Official React Starter Kit] https://github.com/facebookincubator/create-react-app
                                       Doc : https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md
                                       
            Supported by Official React : https://facebook.github.io/react/docs/installation.html
                                            https://facebook.github.io/react/blog/2016/07/22/create-apps-with-no-configuration.html

            Used by Redux : http://redux.js.org/docs/introduction/Examples.html

            Other : (1)https://medium.com/@diamondgfx/learning-react-with-create-react-app-part-1-a12e1833fdc
                    (2)https://medium.com/@diamondgfx/learning-react-with-create-react-app-part-2-3ad99f38b48d
                    (3)https://medium.com/@diamondgfx/learning-react-with-create-react-app-part-3-322447d14192
                    (4)https://medium.com/@diamondgfx/learning-react-with-create-react-app-part-4-9f843c8c1ccc
                    - https://www.fullstackreact.com/articles/using-create-react-app-with-a-server/
                    
            For native : https://github.com/react-community/create-react-native-app/

    !!!  https://github.com/kriasoft/react-starter-kit
    !!   https://github.com/davezuko/react-redux-starter-kit
    !    https://github.com/coryhouse/react-slingshot
    ! http://andrewhfarmer.com/starter-project/
       (Find your starter)



[Note on Officail Tutorial] https://facebook.github.io/react/docs/hello-world.html
    [JSX] : You can embed any JavaScript expression in JSX by wrapping it in curly braces.
            const element = (
              <h1>
                Hello, {formatName(user)}!
              </h1>
            );
            
            We split JSX over multiple lines for readability. While it isn't required, when doing this, we also recommend wrapping it in parentheses to avoid the pitfalls of automatic semicolon insertion.

            !!! After compilation, JSX expressions become regular JavaScript objects.
            This means that you can use JSX inside of if statements and for loops, assign it to variables, accept it as arguments, and return it from functions

            Specifying Attributes with JSX : You should either use quotes (for string values) or curly braces (for expressions), but not both in the same attribute.
            Ex : const element = <div tabIndex="0"></div>;
                 const element = <img src={user.avatarUrl}></img>;

            Since JSX is closer to JavaScript than HTML, React DOM uses camelCase property naming convention instead of HTML attribute names.
            !! For example, class becomes className in JSX, and tabindex becomes tabIndex.
            
            !! <span style={{color: 'red'}}>

            It is safe to embed user input in JSX:
            const title = response.potentiallyMaliciousInput;
            // This is safe:
            const element = <h1>{title}</h1>;
            By default, React DOM escapes any values embedded in JSX before rendering them. Thus it ensures that you can never inject anything that's not explicitly written in your application. Everything is converted to a string before being rendered. This helps prevent XSS (cross-site-scripting) attacks.

            [JSX Represents Objects]
              Babel compiles JSX down to React.createElement() calls.
              These two examples are identical:
                const element = (
                  <h1 className="greeting">
                    Hello, world!
                  </h1>
                );

                const element = React.createElement(
                  'h1',
                  {className: 'greeting'},
                  'Hello, world!'
                );

              React.createElement() performs a few checks to help you write bug-free code but essentially it creates an object.
              These objects are called "React elements". You can think of them as descriptions of what you want to see on the screen. React reads these objects and uses them to construct the DOM and keep it up to date.
    
    [Rendering Elements]
        Elements are the smallest building blocks of React apps.
        An element describes what you want to see on the screen:
        const element = <h1>Hello, world</h1>;
        Unlike browser DOM elements, React elements are plain objects, and are cheap to create. React DOM takes care of updating the DOM to match the React elements.

        !! Elements are what components are "made of".

        <div id="root"></div> 
        We call this a "root" DOM node because everything inside it will be managed by React DOM.
        Applications built with just React usually have a single root DOM node. If you are integrating React into an existing app, you may have as many isolated root DOM nodes as you like.

        To render a React element into a root DOM node, pass both to ReactDOM.render():
          const element = <h1>Hello, world</h1>;
          ReactDOM.render(
            element,
            document.getElementById('root')
          );

        [Updating Element]
            React elements are immutable. Once you create an element, you can't change its children or attributes. An element is like a single frame in a movie: it represents the UI at a certain point in time.

            In practice, most React apps only call ReactDOM.render() once. 

            React DOM compares the element and its children to the previous one, and only applies the DOM updates necessary to bring the DOM to the desired state.

            thinking about how the UI should look at any given moment rather than how to change it over time eliminates a whole class of bugs.

    [Components and Props]            
        Components let you split the UI into independent, reusable pieces, and think about each piece in isolation.
        !! Conceptually, components are like JavaScript functions. They accept arbitrary inputs (called "props") and return React elements describing what should appear on the screen.

        !!! Remember that components may accept arbitrary props, including primitive values, React elements, or functions. React elements like <Contacts /> and <Chat /> are just objects, so you can pass them as props like any other data.
        
        [Functional and Class Components]
          The simplest way to define a component is to write a JavaScript function:
            function Welcome(props) {
              return <h1>Hello, {props.name}</h1>;
            }
          This function is a valid React component because it accepts a single "props" object argument with data and returns a React element. We call such components "functional" because they are literally JavaScript functions.
          You can also use an ES6 class to define a component:
            class Welcome extends React.Component {
              render() {
                return <h1>Hello, {this.props.name}</h1>;
              }
            }
          The above two components are equivalent from React's point of view.

        [Rendering a Component]
            elements can also represent user-defined components:
                const element = <Welcome name="Sara" />;
            When React sees an element representing a user-defined component, it passes JSX attributes to this component as a single object. We call this object "props".
            For example, this code renders "Hello, Sara" on the page:
              function Welcome(props) {
                return <h1>Hello, {props.name}</h1>;
              }
              const element = <Welcome name="Sara" />;
              ReactDOM.render(
                element,
                document.getElementById('root')
              );

            !!! Always start component names with a capital letter.
                For example, <div /> represents a DOM tag, but <Welcome /> represents a component and requires Welcome to be in scope.

            !! Components must return a single root element. This is why we added a <div> to contain all the <Welcome /> elements.
 
            Typically, new React apps have a single App component at the very top. However, if you integrate React into an existing app, you might start bottom-up with a small component like Button and gradually work your way to the top of the view hierarchy.

        [Props are Read-Only]
            Whether you declare a component as a function or a class, it must never modify its own props.
            Such functions are called "pure" because they do not attempt to change their inputs, and always return the same result for the same inputs.
            !!! All React components must act like pure functions with respect to their props.
                "State" allows React components to change their output over time in response to user actions, network responses, and anything else, without violating this rule.

        [State and Lifecycle]
            State is similar to props, but it is "private" and fully controlled by the component.
            We mentioned before that components defined as classes have some additional features. Local state is exactly that: a feature available only to classes.
            !!! If you don't use something in render(), it shouldn't be in the state.

        Add a class constructor that assigns the initial this.state :  
              class Clock extends React.Component {
                constructor(props) {
                  super(props);
                  this.state = {date: new Date()};
                }

                componentDidMount() {
                  this.timerID = setInterval(
                    () => this.tick(),
                    1000
                  );
                }

                componentWillUnmount() {
                  clearInterval(this.timerID);
                }

                tick() {
                  this.setState({
                    date: new Date()
                  });
                }

                render() {
                  return (
                    <div>
                      <h1>Hello, world!</h1>
                      <h2>It is {this.state.date.toLocaleTimeString()}.</h2>
                    </div>
                  );
                }
              }

              ReactDOM.render(
                <Clock />,
                document.getElementById('root')
              );


        Class components should always call the base constructor with props.

        We want to set up a timer whenever the Clock is rendered to the DOM for the first time. This is called "mounting" in React.
        We also want to clear that timer whenever the DOM produced by the Clock is removed. This is called "unmounting" in React.
        These methods are called "lifecycle hooks".

        While this.props is set up by React itself and this.state has a special meaning, you are free to add additional fields to the class manually if you need to store something that is not used for the visual output.

        !!! If you don't use something in render(), it shouldn't be in the state.

        !!! this.setState() : 
           Thanks to the this.setState() call, React knows the state has changed, and calls render() method again to learn what should be on the screen. 

        There are three things you should know about setState() :
            1. Do Not Modify State Directly, this will not re-render a component:
                  // Wrong
                  this.state.comment = 'Hello';
               Instead, use setState().
               The only place where you can assign this.state is the constructor.

            2. State Updates May Be Asynchronous
               React may batch multiple setState() calls into a single update for performance.
               Because this.props and this.state may be updated asynchronously, you should not rely on their values for calculating the next state.

               For example, this code may fail to update the counter:
                  // Wrong
                  this.setState({
                    counter: this.state.counter + this.props.increment,
                  });
               To fix it, use a second form of setState() that accepts a function rather than an object. That function will receive the previous state as the first argument, and the props at the time the update is applied as the second argument:
                  // Correct
                  this.setState(function(prevState, props) {
                    return {
                      counter: prevState.counter + props.increment
                    };
                  });

            3. State Updates are Merged
               When you call setState(), React merges the object you provide into the current state.
               For example, your state may contain several independent variables:
                  constructor(props) {
                    super(props);
                    this.state = {
                      posts: [],
                      comments: []
                    };
                  }
               Then you can update them independently with separate setState() calls:
                  componentDidMount() {
                    fetchPosts().then(response => {
                      this.setState({
                        posts: response.posts
                      });
                    });

                    fetchComments().then(response => {
                      this.setState({
                        comments: response.comments
                      });
                    });
                  }

        [The Data Flows Down]
            Neither parent nor child components can know if a certain component is stateful or stateless.
            This is why state is often called local or encapsulated. It is not accessible to any component other than the one that owns and sets it.
            A component may choose to pass its state down as props to its child components.
            This is commonly called a "top-down" or "unidirectional" data flow. Any state is always owned by some specific component, and any data or UI derived from that state can only affect components "below" them in the tree.
            If you imagine a component tree as a waterfall of props, each component's state is like an additional water source that joins it at an arbitrary point but also flows down.

    [Handling Events] 
        Handling events with React elements is very similar to handling events on DOM elements. There are some syntactic differences:
        #React events are named using camelCase, rather than lowercase.
        #With JSX you pass a function as the event handler, rather than a string.
         For example, the HTML:
           <button onclick="activateLasers()">
             Activate Lasers
           </button>
         is slightly different in React:
           <button onClick={activateLasers}>
             Activate Lasers
           </button>

        # Another difference is that you cannot return false to prevent default behavior in React. You must call preventDefault explicitly. 
        
        When using React you should generally not need to call addEventListener to add listeners to a DOM element after it is created. Instead, just provide a listener when the element is initially rendered.

        When you define a component using an ES6 class, a common pattern is for an event handler to be a method on the class. 
            class Toggle extends React.Component {
              constructor(props) {
                super(props);
                this.state = {isToggleOn: true};

                // This binding is necessary to make `this` work in the callback
                this.handleClick = this.handleClick.bind(this);
              }

              handleClick() {
                this.setState(prevState => ({
                  isToggleOn: !prevState.isToggleOn
                }));
              }

              render() {
                return (
                  <button onClick={this.handleClick}>
                    {this.state.isToggleOn ? 'ON' : 'OFF'}
                  </button>
                );
              }
            }

            ReactDOM.render(
              <Toggle />,
              document.getElementById('root')
            );

        You have to be careful about the meaning of this in JSX callbacks. In JavaScript, class methods are not bound by default. If you forget to bind this.handleClick and pass it to onClick, this will be undefined when the function is actually called.
        This is not React-specific behavior; it is a part of how functions work in JavaScript. Generally, if you refer to a method without () after it, such as onClick={this.handleClick}, you should bind that method.

    [Conditional Rendering]   
        Element Variables : 
            You can use variables to store elements. This can help you conditionally render a part of the component while the rest of the output doesn't change.
                render() {
                  const isLoggedIn = this.state.isLoggedIn;

                  let button = null;
                  if (isLoggedIn) {
                    button = <LogoutButton onClick={this.handleLogoutClick} />;
                  } else {
                    button = <LoginButton onClick={this.handleLoginClick} />;
                  }

                  return (
                    <div>
                      <Greeting isLoggedIn={isLoggedIn} />
                      {button}
                    </div>
                  );
                }


        !! In rare cases you might want a component to hide itself even though it was rendered by another component. To do this return null instead of its render output.

    [Lists and Keys]
        Rendering Multiple Components : 
          const numbers = [1, 2, 3, 4, 5];
          const listItems = numbers.map((number) =>
            <li>{number}</li>
          );
          ReactDOM.render(
            <ul>{listItems}</ul>,
            document.getElementById('root')
          );

        [Key] Keys help React identify which items have changed, are added, or are removed. Keys should be given to the elements inside the array to give the elements a stable identity.
              The best way to pick a key is to use a string that uniquely identifies a list item among its siblings. 
              A good rule of thumb is that elements inside the map() call need keys.
              Keys used within arrays should be unique among their siblings. However they don't need to be globally unique. 

            function NumberList(props) {
              const numbers = props.numbers;
              const listItems = numbers.map((number) =>
                <li key={number.toString()}>
                  {number}
                </li>
              );
              return (
                <ul>{listItems}</ul>
              );
            }

            const numbers = [1, 2, 3, 4, 5];
            ReactDOM.render(
              <NumberList numbers={numbers} />,
              document.getElementById('root')
            );

    [Forms] HTML form elements work a little bit differently from other DOM elements in React, because form elements naturally keep some internal state.
            in most cases, it's convenient to have a JavaScript function that handles the submission of the form and has access to the data that the user entered into the form. The standard way to achieve this is with a technique called "controlled components".

            In HTML, a <textarea> element defines its text by its children:
            <textarea>
              Hello there, this is some text in a text area
            </textarea>
            In React, a <textarea> uses a value attribute instead.
            render() {
              return (
                <form onSubmit={this.handleSubmit}>
                  <label>
                    Name:
                    <textarea value={this.state.value} onChange={this.handleChange} />
                  </label>
                  <input type="submit" value="Submit" />
                </form>
              );
            }

            <input type="text">, <textarea>, and <select> all work very similarly - they all accept a value attribute that you can use to implement a controlled component.

            ES6 computed property name syntax to update the state key corresponding to the given input name:
              this.setState({
                [name]: value
              });
            It is equivalent to this ES5 code:
              var partialState = {};
              partialState[name] = value;
              this.setState(partialState);
            
            [Sample Code]
                  class Reservation extends React.Component {
                    constructor(props) {
                      super(props);
                      this.state = {
                        isGoing: true,
                        numberOfGuests: 2
                      };

                      this.handleInputChange = this.handleInputChange.bind(this);
                    }

                    handleInputChange(event) {
                      const target = event.target;
                      const value = target.type === 'checkbox' ? target.checked : target.value;
                      const name = target.name;

                      this.setState({
                        [name]: value
                      });
                    }

                    handleSubmit(event) {
                      alert('A name was submitted: ' + this.state.value);
                      event.preventDefault();
                    }

                    render() {
                      return (
                        <form onSubmit={this.handleSubmit}>
                          <label>
                            Is going:
                            <input
                              name="isGoing"
                              type="checkbox"
                              checked={this.state.isGoing}
                              onChange={this.handleInputChange} />
                          </label>
                          <br />
                          <label>
                            Number of guests:
                            <input
                              name="numberOfGuests"
                              type="number"
                              value={this.state.numberOfGuests}
                              onChange={this.handleInputChange} />
                          </label>
                        </form>
                      );
                    }
                  }

    [Lifting State Up] 
        Often, several components need to reflect the same changing data. We recommend lifting the shared state up to their closest common ancestor.
        In React, sharing state is accomplished by moving it up to the closest common ancestor of the components that need it. This is called "lifting state up". 

        If the Calculator(common ancestor) owns the shared state, it becomes the "source of truth" for the current temperature in both inputs. It can instruct them both to have values that are consistent with each other.

        There should be a single "source of truth" for any data that changes in a React application. Usually, the state is first added to the component that needs it for rendering. Then, if other components also need it, you can lift it up to their closest common ancestor. Instead of trying to sync the state between different components, you should rely on the top-down data flow.

    [Composition vs Inheritance]
        React has a powerful composition model, and we recommend using composition instead of inheritance to reuse code between components.

        {props.children}
        Some components don't know their children ahead of time. This is especially common for components like Sidebar or Dialog that represent generic "boxes".
        We recommend that such components use the special children prop to pass children elements directly into their output:

          function FancyBorder(props) {
            return (
              <div className={'FancyBorder FancyBorder-' + props.color}>
                {props.children}
              </div>
            );
          }

        This lets other components pass arbitrary children to them by nesting the JSX:
          function WelcomeDialog() {
            return (
              <FancyBorder color="blue">
                <h1 className="Dialog-title">
                  Welcome
                </h1>
                <p className="Dialog-message">
                  Thank you for visiting our spacecraft!
                </p>
              </FancyBorder>
            );
          }
        
        Anything inside the <FancyBorder> JSX tag gets passed into the FancyBorder component as a children prop. Since FancyBorder renders {props.children} inside a <div>, the passed elements appear in the final output.

        [Specialization]
        we might say that a WelcomeDialog is a special case of Dialog.
        In React, this is also achieved by composition, where a more "specific" component renders a more "generic" one and configures it with props:
          function Dialog(props) {
            return (
              <FancyBorder color="blue">
                <h1 className="Dialog-title">
                  {props.title}
                </h1>
                <p className="Dialog-message">
                  {props.message}
                </p>
              </FancyBorder>
            );
          }

          function WelcomeDialog() {
            return (
              <Dialog
                title="Welcome"
                message="Thank you for visiting our spacecraft!" />
            );
          }

        [So What About Inheritance?]
        At Facebook, we use React in thousands of components, and we haven't found any use cases where we would recommend creating component inheritance hierarchies.

        Props and composition give you all the flexibility you need to customize a component's look and behavior in an explicit and safe way.

        !!! Remember that components may accept arbitrary props, including primitive values, React elements, or functions. React elements like <Contacts /> and <Chat /> are just objects, so you can pass them as props like any other data.

        If you want to reuse non-UI functionality between components, we suggest extracting it into a separate JavaScript module.

    [Thinking in React]
        source code : https://codepen.io/rohan10/pen/qRqmjd
    
        Build a static version first :
            To build a static version of your app that renders your data model, you'll want to build components that reuse other components and pass data using props. props are a way of passing data from parent to child.
            don't use state at all to build this static version. State is reserved only for interactivity, that is, data that changes over time. Since this is a static version of the app, you don't need it.

            You can build top-down or bottom-up. That is, you can either start with building the components higher up in the hierarchy or with the ones lower in it. In simpler examples, it's usually easier to go top-down, and on larger projects, it's easier to go bottom-up and write tests as you build.

            React's one-way data flow (also called one-way binding) keeps everything modular and fast.

            There are two types of "model" data in React: props and state. 

            To make your UI interactive, you need to be able to trigger changes to your underlying data model. React makes this easy with state.

            Is it state?
              - Is it passed in from a parent via props? If so, it probably isn't state.
              - Does it remain unchanged over time? If so, it probably isn't state.
              - Can you compute it based on any other state or props in your component? If so, it isn't state.

            Remember: React is all about one-way data flow down the component hierarchy. It may not be immediately clear which component should own what state. This is often the most challenging part for newcomers to understand, so follow these steps to figure it out:
            For each piece of state in your application:
                - Identify every component that renders something based on that state.
                - Find a common owner component (a single component above all the components that need the state in the hierarchy).
                - Either the common owner or another component higher up in the hierarchy should own the state.
                - If you can't find a component where it makes sense to own the state, create a new component simply for holding the state and add it somewhere in the hierarchy above the common owner component.

    [JSX In Depth]
        JSX just provides syntactic sugar for the React.createElement(component, props, ...children) function. The JSX code:

          <MyButton color="blue" shadowSize={2}>
            Click Me
          </MyButton>

        compiles into:

          React.createElement(
            MyButton,
            {color: 'blue', shadowSize: 2},
            'Click Me'
          )

        If you want to test out how some specific JSX is converted into JavaScript, you can try out the online Babel compiler. (https://babeljs.io/repl/#?babili=false&evaluate=true&lineWrap=false&presets=es2015%2Creact%2Cstage-0&targets=&browsers=&builtIns=false&debug=false&code_lz=GYVwdgxgLglg9mABACwKYBt1wBQEpEDeAUIogE6pQhlIA8AJjAG4B8AEhlogO5xnr0AhLQD0jVgG4iAXyA)

        Capitalized types indicate that the JSX tag is referring to a React component. These tags get compiled into a direct reference to the named variable, so if you use the JSX <Foo /> expression, Foo must be in scope.

        Since JSX compiles into calls to React.createElement, the React library must also always be in scope from your JSX code. --> import React from 'react';
        If you don't use a JavaScript bundler and loaded React from a <script> tag, it is already in scope as the React global.

        User-Defined Components Must Be Capitalized
            When an element type starts with a lowercase letter, it refers to a built-in component like <div> or <span> and results in a string 'div' or 'span' passed to React.createElement('div'). Types that start with a capital letter like <Foo /> compile to React.createElement(Foo) and correspond to a component defined or imported in your JavaScript file.

        Choosing the Type at Runtime
            You cannot use a general expression as the React element type. If you do want to use a general expression to indicate the type of the element, just assign it to a capitalized variable first.

              import { PhotoStory, VideoStory } from './stories';
              const components = {
                photo: PhotoStory,
                video: VideoStory
              };

              function Story(props) {
                // Correct! JSX type can be a capitalized variable.
                const SpecificStory = components[props.storyType];
                return <SpecificStory story={props.story} />;
              }

        Props in JSX : 
            (1) JavaScript Expressions as Props
                You can pass any JavaScript expression as a prop, by surrounding it with {}
                if statements and for loops are not expressions in JavaScript, so they can't be used in JSX directly. Instead, you can put these in the surrounding code. For example:
                    function NumberDescriber(props) {
                      let description;
                      if (props.number % 2 == 0) {
                        description = <strong>even</strong>;
                      } else {
                        description = <i>odd</i>;
                      }
                      return <div>{props.number} is an {description} number</div>;
                    }

            (2) String Literals
                You can pass a string literal as a prop. These two JSX expressions are equivalent:
                    <MyComponent message="hello world" />

                    <MyComponent message={'hello world'} />
                When you pass a string literal, its value is HTML-unescaped. So these two JSX expressions are equivalent:
                    <MyComponent message="&lt;3" />

                    <MyComponent message={'<3'} />

            (3) Props Default to "True"
                If you pass no value for a prop, it defaults to true. These two JSX expressions are equivalent:
                    <MyTextBox autocomplete />

                    <MyTextBox autocomplete={true} />

            (4) Spread Attributes
                If you already have props as an object, and you want to pass it in JSX, you can use ... as a "spread" operator to pass the whole props object. These two components are equivalent:
                    function App1() {
                      return <Greeting firstName="Ben" lastName="Hector" />;
                    }

                    function App2() {
                      const props = {firstName: 'Ben', lastName: 'Hector'};
                      return <Greeting {...props} />;
                    }
                Spread attributes can be useful when you are building generic containers.

        Children in JSX : 
            In JSX expressions that contain both an opening tag and a closing tag, the content between those tags is passed as a special prop: props.children. There are several different ways to pass children:

                (1) String Literals
                    You can put a string between the opening and closing tags and props.children will just be that string. This is useful for many of the built-in HTML elements. For example:
                      <MyComponent>Hello world!</MyComponent>
                    This is valid JSX, and props.children in MyComponent will simply be the string "Hello world!".

                    JSX removes whitespace at the beginning and ending of a line. It also removes blank lines. New lines adjacent to tags are removed; new lines that occur in the middle of string literals are condensed into a single space.

                (2) JSX Children
                    You can provide more JSX elements as the children. This is useful for displaying nested components:
                      <MyContainer>
                        <MyFirstComponent />
                        <MySecondComponent />
                      </MyContainer>

                    You can mix together different types of children, so you can use string literals together with JSX children. This is another way in which JSX is like HTML, so that this is both valid JSX and valid HTML:
                      <div>
                        Here is a list:
                        <ul>
                          <li>Item 1</li>
                          <li>Item 2</li>
                        </ul>
                      </div>
                    A React component can't return multiple React elements, but a single JSX expression can have multiple children, so if you want a component to render multiple things you can wrap it in a div like this.

                (3) JavaScript Expressions as Children
                    You can pass any JavaScript expression as children, by enclosing it within {}
                    This is often useful for rendering a list of JSX expressions of arbitrary length. For example, this renders an HTML list:

                        function Item(props) {
                          return <li>{props.message}</li>;
                        }

                        function TodoList() {
                          const todos = ['finish doc', 'submit pr', 'nag dan to review'];
                          return (
                            <ul>
                              {todos.map((message) => <Item key={message} message={message} />)}
                            </ul>
                          );
                        }

                (4) Functions as Children
                    Normally, JavaScript expressions inserted in JSX will evaluate to a string, a React element, or a list of those things. However, props.children works just like any other prop in that it can pass any sort of data, not just the sorts that React knows how to render. For example, if you have a custom component, you could have it take a callback as props.children:
                        // Calls the children callback numTimes to produce a repeated component
                        function Repeat(props) {
                          let items = [];
                          for (let i = 0; i < props.numTimes; i++) {
                            items.push(props.children(i));
                          }
                          return <div>{items}</div>;
                        }

                        function ListOfTenThings() {
                          return (
                            <Repeat numTimes={10}>
                              {(index) => <div key={index}>This is item {index} in the list</div>}
                            </Repeat>
                          );
                        }

                    !! Children passed to a custom component can be anything, as long as that component transforms them into something React can understand before rendering.

                (5) Booleans, Null, and Undefined Are Ignored
                    false, null, undefined, and true are valid children. They simply don't render. 
                    This can be useful to conditionally render React elements. This JSX only renders a <Header /> if showHeader is true:
                        <div>
                          {showHeader && <Header />}
                          <Content />
                        </div>

                    Conversely, if you want a value like false, true, null, or undefined to appear in the output, you have to convert it to a string first:
                        <div>
                          My JavaScript variable is {String(myVariable)}.
                        </div>

    [Typechecking With PropTypes]    
        Note : React.PropTypes has moved into a different package since React v15.5. Please use the prop-types library instead.
        We provide a codemod script to automate the conversion.

        For some applications, you can use JavaScript extensions like Flow or TypeScript to typecheck your whole application. But even if you don't use those, React has some built-in typechecking abilities. To run typechecking on the props for a component, you can assign the special propTypes property:
            import PropTypes from 'prop-types';

            class Greeting extends React.Component {
              render() {
                return (
                  <h1>Hello, {this.props.name}</h1>
                );
              }
            }

            Greeting.propTypes = {
              name: PropTypes.string
            };

        When an invalid value is provided for a prop, a warning will be shown in the JavaScript console.
        For performance reasons, propTypes is only checked in development mode.

        [Default Prop Values]
          You can define default values for your props by assigning to the special defaultProps property:
              class Greeting extends React.Component {
                render() {
                  return (
                    <h1>Hello, {this.props.name}</h1>
                  );
                }
              }

              // Specifies the default values for props:
              Greeting.defaultProps = {
                name: 'Stranger'
              };
          The defaultProps will be used to ensure that this.props.name will have a value if it was not specified by the parent component.     
          The propTypes typechecking happens after defaultProps are resolved, so typechecking will also apply to the defaultProps.

    [Refs and the DOM]
    


       

